"""
from @ian /cq8/ianxxu/chatchat/_TaskPlan/UI/v2.7_demo/tools/python_executor_tool.py

NOTE: to be checked
"""

from IPython.core.interactiveshell import InteractiveShell
import matplotlib.pyplot as plt
import glob, os, io, contextlib, base64, sys, re, pathlib
from typing import Tuple, List
from .register import register_tool

DIR_DEFAULT = pathlib.Path(__file__).parent.parent.parent / "log/sandbox"

re_sub = re.compile(r"\x1b\[[0-9;]*[a-zA-Z]")


def get_output_files(exec_dir: str, update_file_list=False):
    # 先获取之前生成过的文件
    if os.path.exists(os.path.join(exec_dir, "filelist.txt")):
        with open(os.path.join(exec_dir, "filelist.txt")) as f:
            file_list = [file_i.strip() for file_i in f.readlines()]
    else:
        file_list = []
    # 获取当前该目录下的所有文件
    current_file_list = glob.glob(os.path.join(exec_dir, "*"))
    # 过滤出新增的文件
    # new_file_list = [file_i for file_i in current_file_list if (file_i not in file_list and not file_i.endswith('filelist.txt'))]
    new_file_list = [file_i for file_i in current_file_list if file_i not in file_list]
    for i in range(len(new_file_list)):
        if new_file_list[i].endswith("filelist.txt"):
            new_file_list.pop(i)
            break
    # if 'filelist.txt' in new_file_list:
    #     new_file_list.remove('filelist.txt')
    # 将新增的文件写入filelist.txt
    if update_file_list:
        with open(os.path.join(exec_dir, "filelist.txt"), "a") as f:
            for file_i in new_file_list:
                f.write(file_i + "\n")
    print(">>>> file_list: ", exec_dir, "\n", file_list, "\n", current_file_list, "\n", new_file_list, "\n---------------------")
    return new_file_list


def python_executor_tool(code: str, exec_dir: str = DIR_DEFAULT) -> Tuple[str, List[str]]:
    pwd = os.getcwd()  # save the current directory
    code = code.strip()
    if code.startswith("```python"):
        code = code.split("```python")[1].split("```")[0].strip()
    os.makedirs(exec_dir, exist_ok=True)
    os.chdir(exec_dir)

    shell = InteractiveShell.instance()
    # 创建一个StringIO对象，用于获取输出
    output = io.StringIO()
    # 重定向sys.stdout到output
    with contextlib.redirect_stdout(output):
        shell.run_cell(code)
        # 如果有活动的图像，则将其保存为PNG并转换为Base64编码
        if plt.get_fignums():
            img_buffer = io.BytesIO()
            plt.savefig(img_buffer, format="png")
            img_base64 = base64.b64encode(img_buffer.getvalue()).decode("utf-8")
            plt.close()  # 关闭图像，以免影响后续操作
        else:
            img_base64 = None
    output_files = get_output_files(exec_dir)
    if (not output_files) and img_base64:
        # 判断路径是否存在
        image_name = f"image.png"
        if os.path.exists(image_name):
            image_id = 1
            while os.path.exists(f"image({image_id}).png"):
                image_id += 1
            image_name = f"image({image_id}).png"
        with open(image_name, "wb") as f:
            f.write(base64.b64decode(img_base64))
    # 获取输出
    result = output.getvalue()
    # return to the original directory
    os.chdir(pwd)

    return re_sub.sub("", result.strip()), get_output_files(exec_dir, update_file_list=True)


@register_tool()
def code_interpreter(code: str) -> Tuple[str, List[str]]:
    """A Python shell. Use this to execute python commands, and DO NOT execute risk code

    Args:
        code: The python code to execute

    Returns:
        A tuple containing the output of the code execution and a list of files generated by the code execution
    """
    return python_executor_tool(code, DIR_DEFAULT)
